<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APG-AI Prompt Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    
    <style>
        :root {
            --background-dark: #121212;
            --surface-dark: #1E1E1E;
            --input-bg: #2a2a2c;
            --primary-glow: #A78BFA; /* Lavender */
            --secondary-glow: #F472B6; /* Pink */
            --text-primary: #EAEAEA;
            --text-secondary: #A0A0A0;
            --border-color: #333333;
            --border-color-focus: var(--primary-glow);
        }
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: var(--background-dark); 
            color: var(--text-primary);
        }
        .apg-gradient-text { 
            background-image: linear-gradient(90deg, var(--primary-glow), var(--secondary-glow)); 
            background-clip: text; -webkit-background-clip: text; color: transparent;
        }
        .glow-button { 
            background: linear-gradient(90deg, var(--primary-glow), var(--secondary-glow)); 
            transition: all 0.3s ease; 
            box-shadow: 0 0 15px rgba(167, 139, 250, 0.3);
        }
        .glow-button:hover { 
            box-shadow: 0 0 25px rgba(167, 139, 250, 0.5); 
            transform: scale(1.02);
        }
        .glow-button:disabled { 
            background: #333; color: #666; box-shadow: none; cursor: not-allowed; 
        }
        .secondary-button { 
            background-color: var(--surface-dark); 
            border: 1px solid var(--border-color); 
            color: var(--text-primary); 
            transition: all 0.2s ease;
        }
        .secondary-button:hover { 
            background-color: rgba(255, 255, 255, 0.1);
            border-color: var(--text-secondary);
        }
        textarea:focus, input:focus { 
            outline: none; 
            box-shadow: 0 0 15px rgba(167, 139, 250, 0.2); 
            border-color: var(--border-color-focus) !important;
        }
        textarea, input, pre { 
            background-color: var(--input-bg); 
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem; /* 8px */
        }
        
        /* New Loader & Toolbar Styles */
        .toolbar-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background-color: transparent;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }
        .toolbar-btn:hover {
            background-color: #333;
            color: var(--text-primary);
        }
        
        /* New Typing Loader (same as before) */
        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }
        @keyframes blink-caret {
            from, to { border-color: transparent }
            50% { border-color: var(--primary-glow); }
        }
        .typing-loader {
            display: inline-block;
            overflow: hidden;
            white-space: nowrap;
            border-right: .15em solid var(--primary-glow);
            animation: typing 2.5s steps(30, end) infinite,
                       blink-caret .75s step-end infinite;
        }
        
        /* Live Prompt Updating "Pulse" */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .prompt-updating {
            animation: pulse 1.5s ease-in-out infinite;
        }
    </style>
</head>
<body class="min-h-screen w-full p-4 md:p-8">

    <header class="w-full max-w-7xl mx-auto flex justify-between items-center mb-6">
        <div>
            <h1 class="text-2xl md:text-3xl font-bold apg-gradient-text">APG-AI Prompt Studio</h1>
            <p class="text-md text-text-secondary hidden md:block">Your prompt will update live as you type.</p>
        </div>
        <div>
            <button id="start-over-btn" class="secondary-button font-semibold px-6 py-2 rounded-full">
                <i class="fa-solid fa-rotate-left mr-2"></i>Start Over
            </button>
        </div>
    </header>

    <main class="w-full max-w-7xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-6 md:gap-8">
        
        <div id="controls-panel" class="w-full h-full">
            <div class="bg-surface-dark p-5 rounded-lg border border-border-color space-y-5">
                
                <div>
                    <label for="topic-input" class="block text-xl font-semibold mb-3">1. Your Goal</label>
                    <div class="relative w-full">
                        <textarea id="topic-input" rows="5" class="w-full p-3 pr-12" placeholder="e.g., A marketing campaign for a new coffee brand"></textarea>
                        <button type="button" class="voice-btn toolbar-btn" style="position: absolute; right: 10px; top: 10px;" title="Voice Input">
                            <i class="fa-solid fa-microphone"></i>
                        </button>
                    </div>
                </div>

                <div id="refine-btn-container" class="text-center">
                    <button id="refine-btn" class="glow-button text-white font-semibold px-8 py-3 rounded-full w-full" disabled>
                        <i class="fa-solid fa-wand-magic-sparkles mr-2"></i>Refine Goal
                    </button>
                </div>
                
                <div id="questions-container" class="hidden space-y-5 pt-4 border-t border-border-color">
                    </div>

            </div>
        </div>

        <div id="live-prompt-panel" class="w-full h-full">
            <div class="bg-surface-dark p-5 rounded-lg border border-border-color sticky top-8 min-h-[40rem]">
                
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold">2. Live Prompt</h2>
                    <button id="copy-btn" class="secondary-button font-semibold px-6 py-2 rounded-full">
                        <i class="fa-solid fa-copy mr-2"></i><span id="copy-text">Copy</span>
                    </button>
                </div>

                <div id="prompt-placeholder" class="h-full flex flex-col items-center justify-center text-center text-text-secondary p-8">
                    <i class="fa-solid fa-file-lines text-5xl mb-4"></i>
                    <h3 class="font-semibold text-lg text-text-primary">Your prompt will appear here</h3>
                    <p>Start by typing your goal on the left and click "Refine" to begin.</p>
                </div>
                
                <div id="prompt-updating-placeholder" class="hidden h-full flex-col items-center justify-center text-center text-text-secondary p-8">
                    <i class="fa-solid fa-brain text-5xl mb-4 apg-gradient-text"></i>
                    <h3 class="font-semibold text-lg text-text-primary">APG is thinking...</h3>
                    <p>Updating your prompt based on the new info.</p>
                </div>

                <pre id="result-text" class="hidden w-full h-[36rem] p-4 overflow-y-auto whitespace-pre-wrap text-sm"></pre>

            </div>
        </div>
    </main>
    
    <script>
        // --- START OF PROMPT STUDIO SCRIPT ---

        // --- DOM Elements ---
        const dom = {
            topicInput: document.getElementById('topic-input'),
            refineBtn: document.getElementById('refine-btn'),
            refineBtnContainer: document.getElementById('refine-btn-container'),
            questionsContainer: document.getElementById('questions-container'),
            
            livePromptPanel: document.getElementById('live-prompt-panel'),
            promptPlaceholder: document.getElementById('prompt-placeholder'),
            promptUpdatingPlaceholder: document.getElementById('prompt-updating-placeholder'),
            resultText: document.getElementById('result-text'),
            
            copyBtn: document.getElementById('copy-btn'),
            copyText: document.getElementById('copy-text'),
            startOverBtn: document.getElementById('start-over-btn'),
        };

        // --- State ---
        let state = {
            userTopic: '',
            questionsAndAnswers: [],
            isRefined: false, // Has the user clicked "Refine" yet?
            isUpdating: false, // Are we waiting for an API call?
        };

        // --- Helper: Debounce ---
        // Prevents API calls on *every* keystroke.
        // Waits for the user to stop typing for 'delay' ms.
        function debounce(func, delay = 500) {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        // --- API Call Logic (Unchanged) ---
        async function callApi(prompt, systemInstruction) {
            const API_URL = `/api/generate`; 
            const payload = { prompt, systemInstruction };
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorBody = await response.json().catch(() => ({}));
                    return `Error: ${errorBody.error || response.statusText}`;
                }
                const data = await response.json();
                return data.text;
            } catch (error) {
                console.error("Fetch Error to backend:", error);
                return "Error: Could not connect to the server.";
            }
        }

        // --- UI Update Logic ---
        
        /** Shows a "typing" loader in the questions container */
        const showQuestionLoading = () => {
            dom.questionsContainer.classList.remove('hidden');
            dom.questionsContainer.innerHTML = `
                <div class="text-center text-text-secondary py-4">
                    <span class="typing-loader">APG is preparing your form...</span>
                </div>`;
        };
        
        /** Shows an error in the questions container */
        const showQuestionError = (message) => {
            dom.questionsContainer.innerHTML = `<div class="text-center text-red-400 p-4 bg-red-900/20 rounded-lg">${message}</div>`;
        };

        /** Updates the right-hand "Live Prompt" panel based on state */
        const updatePromptView = () => {
            if (state.isUpdating) {
                // Show "Thinking" placeholder
                dom.promptPlaceholder.classList.add('hidden');
                dom.promptUpdatingPlaceholder.classList.remove('hidden');
                dom.resultText.classList.add('hidden');
                dom.livePromptPanel.classList.add('prompt-updating');
            } else if (!state.isRefined && !dom.topicInput.value.trim()) {
                // Show "Start" placeholder
                dom.promptPlaceholder.classList.remove('hidden');
                dom.promptUpdatingPlaceholder.classList.add('hidden');
                dom.resultText.classList.add('hidden');
                dom.livePromptPanel.classList.remove('prompt-updating');
            } else {
                // Show the final prompt text
                dom.promptPlaceholder.classList.add('hidden');
                dom.promptUpdatingPlaceholder.classList.add('hidden');
                dom.resultText.classList.remove('hidden');
                dom.livePromptPanel.classList.remove('prompt-updating');
            }
        };

        // --- Core Logic ---

        /**
         * Reads all Q&As from the DOM inputs and updates the state.
         */
        const buildStateFromForm = () => {
            state.userTopic = dom.topicInput.value.trim();
            state.questionsAndAnswers = [];
            
            const inputs = dom.questionsContainer.querySelectorAll('input[data-question], textarea[data-question]');
            
            inputs.forEach(input => {
                state.questionsAndAnswers.push({
                    question: input.dataset.question,
                    answer: input.value.trim() || "(No answer provided)"
                });
            });
        };

        /**
         * The MAIN function. Called every time an input changes.
         * Gets the full state and generates a new "live" prompt.
         */
        const updateLivePrompt = async () => {
            // Don't run if we haven't even clicked "Refine"
            if (!state.isRefined) return;
            
            // Don't run if the goal is empty
            if (!dom.topicInput.value.trim()) {
                resetToStart(); // Clear everything
                return;
            }

            state.isUpdating = true;
            updatePromptView();
            
            buildStateFromForm(); // Collect all current data

            const qasText = state.questionsAndAnswers.map(qa => `- Question: ${qa.question}\n- Answer: ${qa.answer}`).join('\n');
            const refinementSection = qasText ? `\n**User's Refinements (Questions & Answers):**\n${qasText}` : '';

            const instruction = `Your role is an expert prompt engineer. Your ONLY task is to synthesize the user's goal and their answers into a single, comprehensive, and detailed prompt ready for another AI model.
You MUST NOT answer or fulfill the user's request yourself. You are building the prompt FOR them.
The final output must ONLY be the generated prompt text, with no extra conversation, preamble, or explanations.
**User's Initial Goal:**
${state.userTopic}
${refinementSection}
Now, generate the final, copy-and-paste-ready prompt below.`;

            const finalPrompt = await callApi("Synthesize the information into a final prompt.", instruction);
            
            if (finalPrompt.startsWith("Error:")) {
                dom.resultText.textContent = `// Error generating prompt. Please try again.\n\n${finalPrompt}`;
            } else {
                dom.resultText.textContent = finalPrompt.trim();
            }
            
            state.isUpdating = false;
            updatePromptView();
        };

        // Create a debounced version of the update function
        const debouncedUpdateLivePrompt = debounce(updateLivePrompt, 500);

        /**
         * Loads the initial 5 questions into the control panel.
         */
        const loadInitialQuestions = async () => {
            state.isRefined = true;
            dom.refineBtnContainer.classList.add('hidden');
            showQuestionLoading();
            
            buildStateFromForm(); // Get the topic
            
            const instruction = `You are an expert prompt engineering assistant. Your goal is to help a user refine their initial goal.
User's Initial Goal: "${state.userTopic}"
**Your Task:** Generate 5 insightful, clarifying questions to ask the user. The questions should cover different aspects like Audience, Format, Tone, Key Details, and Constraints.
**Return ONLY a JSON array of 5 strings**, like: ["Question 1", "Question 2", "Question 3", "Question 4", "Question 5"]`;

            const questionText = await callApi("Generate 5 initial questions.", instruction);

            let questions;
            try {
                questions = JSON.parse(questionText);
                if (!Array.isArray(questions) || questions.length === 0 || !questions.every(q => typeof q === 'string')) {
                    throw new Error('Invalid JSON array format.');
                }
            } catch (error)_ {
                console.error("Failed to parse questions:", error, questionText);
                showQuestionError("Error: Could not generate questions. The AI returned an invalid format. Please try again.");
                dom.refineBtnContainer.classList.remove('hidden'); // Show button to try again
                state.isRefined = false;
                return;
            }

            dom.questionsContainer.innerHTML = ''; // Clear loading message
            
            // Create the form
            questions.forEach((q, index) => {
                const questionEl = document.createElement('div');
                questionEl.className = 'question-item';
                questionEl.innerHTML = `
                    <label for="q-${index}" class="block text-md font-medium text-left mb-2">${q}</label>
                    <div class="relative w-full">
                        <input type="text" id="q-${index}" data-question="${q}" class="w-full p-3 pr-12 rounded-lg" placeholder="Your answer...">
                        <button type="button" class="voice-btn toolbar-btn" style="position: absolute; right: 6px; top: 50%; transform: translateY(-50%);" title="Voice Input">
                            <i class="fa-solid fa-microphone"></i>
                        </button>
                    </div>
                `;
                dom.questionsContainer.appendChild(questionEl);
            });
            
            // IMPORTANT: Now that questions are loaded, do the *first* live update.
            updateLivePrompt();
        };

        /**
         * Resets the entire UI to its starting state.
         */
        const resetToStart = () => {
            state = { userTopic: '', questionsAndAnswers: [], isRefined: false, isUpdating: false };
            
            dom.topicInput.value = '';
            dom.refineBtn.disabled = true;
            dom.refineBtnContainer.classList.remove('hidden');
            
            dom.questionsContainer.innerHTML = '';
            dom.questionsContainer.classList.add('hidden');
            
            dom.resultText.textContent = '';
            updatePromptView(); // This will show the main placeholder
        };

        // --- Voice Input (Speech Recognition) Logic (Unchanged) ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = SpeechRecognition ? new SpeechRecognition() : null;
        let currentTargetInput = null; 

        if (recognition) {
            recognition.continuous = false; 
            recognition.lang = 'en-US';
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            recognition.onresult = (event) => {
                const transcript = event.results[event.results.length - 1][0].transcript.trim();
                
                if (currentTargetInput) {
                    currentTargetInput.value += (currentTargetInput.value.length > 0 ? ' ' : '') + transcript;
                    // Manually trigger the 'input' event to fire the debounce
                    currentTargetInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            };

            recognition.onerror = (event) => {
                if (currentTargetInput) {
                    currentTargetInput.closest('.relative').querySelector('.voice-btn i').className = 'fa-solid fa-microphone';
                }
            };

            recognition.onend = () => {
                if (currentTargetInput) {
                    currentTargetInput.closest('.relative').querySelector('.voice-btn i').className = 'fa-solid fa-microphone';
                    currentTargetInput = null; 
                }
            };

            const handleVoiceInputClick = (event) => {
                const voiceBtn = event.target.closest('.voice-btn');
                if (!voiceBtn) return; 

                const target = voiceBtn.closest('.relative').querySelector('textarea, input[type="text"]');
                if (!target) return; 

                if (currentTargetInput) {
                    recognition.stop();
                } else {
                    currentTargetInput = target;
                    recognition.start();
                    voiceBtn.querySelector('i').className = 'fa-solid fa-stop apg-gradient-text';
                }
            };
            
            // Use event delegation on the body
            document.body.addEventListener('click', handleVoiceInputClick);

        } else {
            console.warn("Speech Recognition not supported by this browser.");
            const style = document.createElement('style');
            style.innerHTML = `.voice-btn { display: none; }`;
            document.head.appendChild(style);
        }
        
        // --- Event Listeners ---

        // 1. Goal Input
        dom.topicInput.addEventListener('input', () => {
            const hasText = dom.topicInput.value.trim() !== '';
            dom.refineBtn.disabled = !hasText;
            
            // If we've already refined, update live.
            if (state.isRefined) {
                debouncedUpdateLivePrompt();
            }
        });

        // 2. Refine Button
        dom.refineBtn.addEventListener('click', () => {
            if (dom.topicInput.value.trim()) {
                loadInitialQuestions();
            }
        });

        // 3. Question Inputs (Event Delegation)
        // Listen for 'input' on any dynamic input inside the container
        dom.questionsContainer.addEventListener('input', (event) => {
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                debouncedUpdateLivePrompt();
            }
        });

        // 4. Top-level Buttons
        dom.copyBtn.addEventListener('click', () => {
            if (!dom.resultText.textContent || dom.resultText.textContent.startsWith('// Error')) {
                return; // Don't copy placeholder or error
            }
            navigator.clipboard.writeText(dom.resultText.textContent).then(() => {
                dom.copyText.textContent = 'Copied!';
                setTimeout(() => { dom.copyText.textContent = 'Copy'; }, 2000);
            });
        });

        dom.startOverBtn.addEventListener('click', resetToStart);

        // --- Initial UI Setup ---
        resetToStart();
        
    </script>
</body>
</html>
