<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APG-AI Prompt Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <style>
        :root {
            --background-dark: #121212;
            --surface-dark: #1E1E1E;
            --input-bg: #2a2a2c;
            --primary-glow: #A78BFA; /* Lavender */
            --secondary-glow: #F472B6; /* Pink */
            --text-primary: #EAEAEA;
            --text-secondary: #A0A0A0;
            --border-color: #333333;
            --border-color-focus: var(--primary-glow);
        }
        body { font-family: 'Inter', sans-serif; background-color: var(--background-dark); color: var(--text-primary); }
        .apg-gradient-text { background-image: linear-gradient(90deg, var(--primary-glow), var(--secondary-glow)); background-clip: text; -webkit-background-clip: text; color: transparent; }
        .glow-button { background: linear-gradient(90deg, var(--primary-glow), var(--secondary-glow)); transition: all 0.3s ease; box-shadow: 0 0 15px rgba(167, 139, 250, 0.3); }
        .glow-button:hover { box-shadow: 0 0 25px rgba(167, 139, 250, 0.5); transform: scale(1.02); }
        .glow-button:disabled { background: #333; color: #666; box-shadow: none; cursor: not-allowed; }
        .secondary-button { background-color: var(--surface-dark); border: 1px solid var(--border-color); color: var(--text-primary); transition: background-color 0.2s; }
        .secondary-button:hover { background-color: rgba(255, 255, 255, 0.1); }
        textarea:focus, input:focus { outline: none; box-shadow: 0 0 15px rgba(167, 139, 250, 0.2); border-color: var(--border-color-focus) !important; }
        .step-item.active .step-circle { background-color: var(--primary-glow); border-color: var(--primary-glow); color: var(--background-dark); transform: scale(1.1); }
        .step-item.active .step-text { color: var(--text-primary); font-weight: 600; }
        .step-item .step-circle { transition: all 0.3s ease; }
        .step-line { background-color: var(--border-color); }
        textarea, input, pre { background-color: var(--input-bg); color: var(--text-primary); }

        .attachment-toolbar {
            position: relative;
            display: flex;
            align-items: center;
        }

        .toolbar-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            background-color: var(--surface-dark);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            margin: 0 4px;
            cursor: pointer;
            font-size: 18px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .toolbar-btn:hover {
            background-color: #333;
            color: var(--text-primary);
        }

        .options-menu {
            position: absolute;
            bottom: 60px;
            left: -10px;
            display: flex;
            padding: 8px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            opacity: 0;
            transform: translateY(10px);
            visibility: hidden;
            transition: all 0.2s ease-out;
            z-index: 10;
        }

        .options-menu.visible {
            opacity: 1;
            transform: translateY(0);
            visibility: visible;
        }

        .file-input {
            display: none;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-2xl text-center">
        <h1 class="text-4xl md:text-5xl font-bold mb-3 apg-gradient-text">APG-AI Prompt Generator</h1>
        <p class="text-lg text-text-secondary mb-8">Create the perfect prompts, <span class="apg-gradient-text font-semibold">every time.</span></p>

        <div class="w-full bg-surface-dark p-6 rounded-2xl border border-border-color">
            <div id="tool-view">
                <div class="flex items-center justify-center w-full mb-8">
                    <div class="step-item flex items-center text-text-secondary" id="step-1-indicator"><div class="step-circle w-8 h-8 rounded-full bg-surface-dark border-2 border-border-color flex items-center justify-center font-bold">1</div><span class="step-text ml-3">Goal</span></div>
                    <div class="step-line flex-grow h-0.5 mx-4"></div>
                    <div class="step-item flex items-center text-text-secondary" id="step-2-indicator"><div class="step-circle w-8 h-8 rounded-full bg-surface-dark border-2 border-border-color flex items-center justify-center font-bold">2</div><span class="step-text ml-3">Refine</span></div>
                    <div class="step-line flex-grow h-0.5 mx-4"></div>
                    <div class="step-item flex items-center text-text-secondary" id="step-3-indicator"><div class="step-circle w-8 h-8 rounded-full bg-surface-dark border-2 border-border-color flex items-center justify-center font-bold">3</div><span class="step-text ml-3">Generate</span></div>
                </div>

                <div id="step-1-content">
                    <h3 class="text-2xl font-semibold mb-4">What's your topic or goal?</h3>
                    <div class="relative w-full">
                        <textarea id="topic-input" rows="5" class="w-full p-3 pr-12 rounded-lg border border-border-color transition-colors duration-200" placeholder="e.g., A marketing campaign for a new coffee brand"></textarea>
                        <button type="button" class="voice-btn toolbar-btn" style="position: absolute; right: 10px; top: 10px; width: 36px; height: 36px;" title="Voice Input">
                            <i class="fa-solid fa-microphone"></i>
                        </button>
                    </div>
                    
                    <div class="attachment-toolbar mt-4">
                        <button type="button" id="toggleBtn" class="toolbar-btn" title="Add attachments">
                            <i class="fa-solid fa-plus"></i>
                        </button>
                
                        <div id="optionsMenu" class="options-menu">
                            
                            <label for="photoUpload" class="toolbar-btn" title="Add Photo">
                                <i class="fa-solid fa-image"></i>
                            </label>
                            <input type="file" id="photoUpload" class="file-input" accept="image/*">
                
                            <label for="fileUpload" class="toolbar-btn" title="Add File">
                                <i class="fa-solid fa-paperclip"></i>
                            </label>
                            <input type="file" id="fileUpload" class="file-input">
                            
                        </div>
                    </div>

                    <button id="step-1-btn" class="glow-button text-white font-semibold px-8 py-3 rounded-full mt-6" disabled>Continue</button>
                </div>

                <div id="step-2-content" class="hidden">
                    <h3 id="step-2-title" class="text-2xl font-semibold mb-4">Refine your prompt.</h3>
                    <div id="questions-container" class="space-y-4 text-left"></div>
                    <div id="refine-options" class="hidden mt-6 space-x-2">
                        <button id="add-input-btn" class="secondary-button font-semibold px-6 py-3 rounded-full">Add Manual Input</button>
                        <button id="more-questions-btn" class="secondary-button font-semibold px-6 py-3 rounded-full">Ask 3 More Questions</button>
                        <button id="generate-prompt-btn" class="glow-button text-white font-semibold px-6 py-3 rounded-full">Generate Prompt</button>
                    </div>
                </div>
                
                <div id="step-3-content" class="hidden">
                    <h3 class="text-2xl font-semibold mb-4">Your Generated Prompt</h3>
                    <div id="result-container" class="text-left">
                        <pre id="result-text" class="w-full p-4 rounded-lg overflow-x-auto whitespace-pre-wrap text-sm min-h-[16rem]"></pre>
                        <div class="flex items-center justify-center flex-wrap gap-4 mt-6">
                            <button id="copy-btn" class="glow-button text-white font-semibold px-8 py-3 rounded-full"><span id="copy-text">Copy Prompt</span></button>
                            <button id="refine-more-btn" class="secondary-button font-semibold px-8 py-3 rounded-full">Refine More</button>
                            <button id="start-over-btn" class="secondary-button font-semibold px-8 py-3 rounded-full">Start Over</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // --- START OF MODIFIED SCRIPT ---
        const dom = {
            stepIndicators: [document.getElementById('step-1-indicator'), document.getElementById('step-2-indicator'), document.getElementById('step-3-indicator')],
            stepContents: [document.getElementById('step-1-content'), document.getElementById('step-2-content'), document.getElementById('step-3-content')],
            step1Btn: document.getElementById('step-1-btn'),
            topicInput: document.getElementById('topic-input'),
            questionsContainer: document.getElementById('questions-container'),
            step2Title: document.getElementById('step-2-title'),
            refineOptions: document.getElementById('refine-options'),
            addInputBtn: document.getElementById('add-input-btn'),
            moreQuestionsBtn: document.getElementById('more-questions-btn'),
            generatePromptBtn: document.getElementById('generate-prompt-btn'),
            resultText: document.getElementById('result-text'),
            copyBtn: document.getElementById('copy-btn'),
            copyText: document.getElementById('copy-text'),
            refineMoreBtn: document.getElementById('refine-more-btn'),
            startOverBtn: document.getElementById('start-over-btn'),
        };

        let state = {
            currentStep: 0,
            userTopic: '',
            questionsAndAnswers: [], // This will be built from the form
            manualInput: '',
            generatedPrompt: ''
        };

        // --- API Call Logic (Unchanged) ---
        async function callApi(prompt, systemInstruction) {
            const API_URL = `/api/generate`; 
            const payload = { prompt, systemInstruction };
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorBody = await response.json().catch(() => ({}));
                    console.error("API Error from backend:", errorBody);
                    return `Error: ${errorBody.error || response.statusText}`;
                }
                const data = await response.json();
                return data.text;
            } catch (error) {
                console.error("Fetch Error to backend:", error);
                return "Error: Could not connect to the server.";
            }
        }

        // --- UI Update Logic (Unchanged) ---
        const updateStepUI = () => {
            dom.stepIndicators.forEach((indicator, index) => indicator.classList.toggle('active', index === state.currentStep));
            dom.stepContents.forEach((content, index) => content.classList.toggle('hidden', index !== state.currentStep));
        };

        const showLoading = (container, message) => {
            container.innerHTML = `<div class="text-center text-text-secondary">${message}</div>`;
        };

        const showError = (container, message) => {
            container.innerHTML = `<div class="text-center text-red-400 p-4 bg-red-900/20 rounded-lg">${message}</div>`;
        };
        
        // --- Step 2: Question Logic (MODIFIED) ---

        /**
         * Loads the initial 5 questions as a form.
         */
        const loadInitialQuestions = async () => {
            state.currentStep = 1;
            updateStepUI();
            dom.refineOptions.classList.add('hidden');
            showLoading(dom.questionsContainer, 'APG is preparing your refinement form...');
            
            const instruction = `You are an expert prompt engineering assistant. Your goal is to help a user refine their initial goal.
User's Initial Goal: "${state.userTopic}"
**Your Task:** Generate 5 insightful, clarifying questions to ask the user. The questions should cover different aspects like Audience, Format, Tone, Key Details, and Constraints.
**Return ONLY a JSON array of 5 strings**, like: ["Question 1", "Question 2", "Question 3", "Question 4", "Question 5"]`;

            const questionText = await callApi("Generate 5 initial questions.", instruction);

            let questions;
            try {
                questions = JSON.parse(questionText);
                if (!Array.isArray(questions) || questions.length === 0 || !questions.every(q => typeof q === 'string')) {
                    throw new Error('Invalid JSON array format.');
                }
            } catch (error) {
                console.error("Failed to parse questions:", error, questionText);
                showError(dom.questionsContainer, "Error: Could not generate questions. The AI returned an invalid format. Please try again.");
                return;
            }

            dom.step2Title.textContent = 'Refine your prompt.';
            dom.questionsContainer.innerHTML = ''; // Clear loading message
            
            // Create the form
            questions.forEach((q, index) => {
                const questionEl = document.createElement('div');
                // --- NEW HTML STRUCTURE FOR FOLLOW-UPS & MANUAL INPUT ---
                questionEl.className = 'question-item space-y-2 mb-4';
                // --- MODIFIED: Added relative wrapper, pr-12, and voice button to input ---
                questionEl.innerHTML = `
                    <label for="q-${index}" class="block text-lg font-medium text-left">${q}</label>
                    <div class="relative w-full">
                        <input type="text" id="q-${index}" data-question="${q}" class="w-full p-3 pr-12 rounded-lg border border-border-color transition-colors duration-200" placeholder="Your answer...">
                        <button type="button" class="voice-btn toolbar-btn" style="position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 36px; height: 36px;" title="Voice Input">
                            <i class="fa-solid fa-microphone"></i>
                        </button>
                    </div>
                    <div class="text-right mt-1 space-x-4">
                        <button type="button" class="manual-input-btn-specific text-sm text-pink-400 hover:underline" data-q-index="${index}">
                            Add manual input
                        </button>
                        <button type="button" class="follow-up-btn text-sm text-primary-glow hover:underline" data-q-index="${index}">
                            Add follow-up
                        </button>
                    </div>
                    <div class="manual-input-container-specific ml-4 mt-2"></div>
                    <div class="follow-up-container ml-4 border-l-2 border-border-color pl-4 mt-2"></div>
                `;
                // --- END NEW HTML STRUCTURE ---
                dom.questionsContainer.appendChild(questionEl);
            });

            dom.refineOptions.classList.remove('hidden');
            dom.addInputBtn.style.display = 'inline-block'; 
        };

        /**
         * Asks for 3 more questions and appends them to the form.
         */
        const askMoreQuestions = async () => {
            dom.refineOptions.classList.add('hidden');
            
            const loadingEl = document.createElement('div');
            loadingEl.id = 'more-questions-loading';
            loadingEl.className = 'text-center text-text-secondary mt-4';
            loadingEl.textContent = 'APG is thinking of more questions...';
            dom.questionsContainer.appendChild(loadingEl);

            buildStateFromForm(); 
            
            const previousQAs = state.questionsAndAnswers.map(qa => `Q: ${qa.question}\nA: ${qa.answer}`).join('\n\n');

            const instruction = `You are an expert prompt assistant. A user is refining a goal.
User's Goal: "${state.userTopic}"
Previously asked questions and answers:
${previousQAs || 'None yet.'}
**Your Task:** Ask 3 *new*, *different* questions that haven't been covered.
**Return ONLY a JSON array of 3 strings**, like: ["New Q1", "New Q2", "New Q3"]`;

            const questionText = await callApi("Generate 3 more questions.", instruction);
            document.getElementById('more-questions-loading').remove(); // Remove loading message

            let newQuestions;
            try {
                newQuestions = JSON.parse(questionText);
                if (!Array.isArray(newQuestions) || !newQuestions.every(q => typeof q === 'string')) {
                    throw new Error('Invalid JSON array format.');
                }
            } catch (error) {
                console.error("Failed to parse new questions:", error, questionText);
                alert('Could not generate more questions. The AI returned an invalid format. Please try again.');
                dom.refineOptions.classList.remove('hidden');
                return;
            }

            // Append new questions to the form
            const baseIndex = dom.questionsContainer.querySelectorAll('.question-item').length;
            newQuestions.forEach((q, index) => {
                const newIndex = baseIndex + index;
                const questionEl = document.createElement('div');
                // --- ADDING NEW QUESTIONS WITH FULL CAPABILITIES ---
                questionEl.className = 'question-item space-y-2 mb-4';
                // --- MODIFIED: Added relative wrapper, pr-12, and voice button to input ---
                questionEl.innerHTML = `
                    <label for="q-${newIndex}" class="block text-lg font-medium text-left">${q}</label>
                    <div class="relative w-full">
                        <input type="text" id="q-${newIndex}" data-question="${q}" class="w-full p-3 pr-12 rounded-lg border border-border-color transition-colors duration-200" placeholder="Your answer...">
                        <button type="button" class="voice-btn toolbar-btn" style="position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 36px; height: 36px;" title="Voice Input">
                            <i class="fa-solid fa-microphone"></i>
                        </button>
                    </div>
                    <div class="text-right mt-1 space-x-4">
                        <button type="button" class="manual-input-btn-specific text-sm text-pink-400 hover:underline" data-q-index="${newIndex}">
                            Add manual input
                        </button>
                        <button type="button" class="follow-up-btn text-sm text-primary-glow hover:underline" data-q-index="${newIndex}">
                            Add follow-up
                        </button>
                    </div>
                    <div class="manual-input-container-specific ml-4 mt-2"></div>
                    <div class="follow-up-container ml-4 border-l-2 border-border-color pl-4 mt-2"></div>
                `;
                // --- END NEW STRUCTURE ---
                dom.questionsContainer.appendChild(questionEl);
            });
            
            dom.refineOptions.classList.remove('hidden');
        };

        /**
         * Helper function to read all Q&As from the DOM inputs and update the state.
         */
        const buildStateFromForm = () => {
            state.questionsAndAnswers = [];
            // --- MODIFIED SELECTOR ---
            // Select all inputs AND textareas that have a data-question attribute
            const inputs = dom.questionsContainer.querySelectorAll('input[type="text"][data-question], textarea[data-question]');
            
            inputs.forEach(input => {
                state.questionsAndAnswers.push({
                    question: input.dataset.question,
                    answer: input.value.trim() || "(No answer provided)"
                });
            });

            // Also get *general* manual input
            const manualInput = document.getElementById('manual-input');
            state.manualInput = manualInput ? manualInput.value.trim() : '';
        };

        // --- NEW FUNCTION: Handles clicking the "Add manual input" button for a specific question ---
        const handleSpecificManualInputClick = (event) => {
            if (!event.target.classList.contains('manual-input-btn-specific')) {
                return; // Exit if not the correct button
            }

            const btn = event.target;
            btn.disabled = true;

            const qIndex = btn.dataset.qIndex;
            const mainInput = document.getElementById(`q-${qIndex}`); // Get the main input
            const mainQuestionText = mainInput.dataset.question; // Get its question text
            
            // Find the container specific to this question item
            const manualInputContainer = btn.closest('.question-item').querySelector('.manual-input-container-specific');
            
            const inputId = `q-${qIndex}-manual`;

            // Add the textarea
            // --- MODIFIED: Added relative wrapper, pr-12, and voice button to textarea ---
            manualInputContainer.innerHTML = `
                <label for="${inputId}" class="block text-lg font-medium text-left text-text-secondary">Additional details for this question:</label>
                <div class="relative w-full">
                    <textarea id="${inputId}" data-question="(Manual Details for: ${mainQuestionText})" class="w-full p-3 pr-12 rounded-lg border border-border-color transition-colors duration-200 mt-2" rows="3" placeholder="Add your specific details here..."></textarea>
                    <button type="button" class="voice-btn toolbar-btn" style="position: absolute; right: 10px; top: 10px; width: 36px; height: 36px;" title="Voice Input">
                        <i class="fa-solid fa-microphone"></i>
                    </button>
                </div>
            `;
            
            // Remove the button
            btn.remove();
        };

        // --- Handles clicking the "Add follow-up" button (Unchanged) ---
        const handleFollowUpClick = async (event) => {
            if (!event.target.classList.contains('follow-up-btn')) {
                return; // Exit if the click wasn't on a follow-up button
            }

            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Thinking...';

            const qIndex = btn.dataset.qIndex;
            const mainInput = document.getElementById(`q-${qIndex}`);
            const mainQuestionText = mainInput.dataset.question;
            const mainAnswerValue = mainInput.value.trim();
            const followUpContainer = btn.closest('.question-item').querySelector('.follow-up-container');

            const instruction = `You are a helpful assistant. The user's main goal is "${state.userTopic}".
The main question you just asked was: "${mainQuestionText}"
The user's answer to that question is: "${mainAnswerValue || '(No answer yet)'}"
Based on this, ask ONE single, concise, relevant follow-up question to get more detail.
Return ONLY the text of the single follow-up question.`;

            const followUpQuestionText = await callApi("Generate a follow-up question.", instruction);

            if (followUpQuestionText && !followUpQuestionText.startsWith("Error:")) {
                const followUpId = `q-${qIndex}-followup`;
                // --- MODIFIED: Added relative wrapper, pr-12, and voice button to input ---
                followUpContainer.innerHTML = `
                    <label for="${followUpId}" class="block text-lg font-medium text-left text-text-secondary">${followUpQuestionText}</label>
                    <div class="relative w-full">
                        <input type="text" id="${followUpId}" data-question="${followUpQuestionText}" class="w-full p-3 pr-12 rounded-lg border border-border-color transition-colors duration-200 mt-2" placeholder="Your answer...">
                        <button type="button" class="voice-btn toolbar-btn" style="position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 36px; height: 36px;" title="Voice Input">
                            <i class="fa-solid fa-microphone"></i>
                        </button>
                    </div>
                `;
                btn.remove(); // Remove the "Add follow-up" button after it's used
            } else {
                console.error("Failed to get follow-up:", followUpQuestionText);
                btn.textContent = 'Add follow-up'; // Reset on error
                btn.disabled = false;
                followUpContainer.innerHTML = `<span class="text-red-400 text-sm">Could not load question. Try again.</span>`;
                setTimeout(() => { followUpContainer.innerHTML = ''; }, 3000);
            }
        };

        // --- Step 3: Prompt Generation Logic (Unchanged) ---
        // This function works as-is because buildStateFromForm() now collects all inputs
        const generatePrompt = async () => {
            state.currentStep = 2; // Keep UI on refine step while loading
            updateStepUI();
            showLoading(dom.questionsContainer, 'Generating your final prompt...');
            dom.refineOptions.classList.add('hidden');
            
            buildStateFromForm(); // Collects all data from inputs and textareas

            const qasText = state.questionsAndAnswers.map(qa => `- Question: ${qa.question}\n- Answer: ${qa.answer}`).join('\n');
            // state.manualInput is from the *general* button at the bottom
            const manualInputSection = state.manualInput ? `\n**Additional User-Provided Details:**\n${state.manualInput}` : '';

            const instruction = `Your role is an expert prompt engineer. Your ONLY task is to synthesize the user's goal and their answers into a single, comprehensive, and detailed prompt ready for another AI model.
You MUST NOT answer or fulfill the user's request yourself. You are building the prompt FOR them.
The final output must ONLY be the generated prompt text, with no extra conversation, preamble, or explanations like "Here is your prompt:".
**User's Initial Goal:**
${state.userTopic}
**User's Refinements (Questions & Answers):**
${qasText}
${manualInputSection}
Now, generate the final, copy-and-paste-ready prompt below.`;

            const finalPrompt = await callApi("Synthesize the information into a final prompt.", instruction);
            
            if (!finalPrompt || finalPrompt.startsWith("Error:")) {
                showError(dom.questionsContainer, finalPrompt);
                dom.refineOptions.classList.remove('hidden');
            } else {
                state.generatedPrompt = finalPrompt.trim();
                dom.resultText.textContent = state.generatedPrompt;
                state.currentStep = 2; 
                updateStepUI();
            }
        };

        // --- Toolbar JS (Unchanged) ---
        const toggleButton = document.getElementById('toggleBtn');
        const optionsMenu = document.getElementById('optionsMenu');
        toggleButton.addEventListener('click', (event) => {
            event.stopPropagation();
            optionsMenu.classList.toggle('visible');
        });
        document.addEventListener('click', () => {
            if (optionsMenu.classList.contains('visible')) {
                optionsMenu.classList.remove('visible');
            }
        });
        optionsMenu.addEventListener('click', (event) => {
            event.stopPropagation();
        });
        const photoUpload = document.getElementById('photoUpload');
        const fileUpload = document.getElementById('fileUpload');
        photoUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                console.log('Photo selected:', file.name);
                optionsMenu.classList.remove('visible');
            }
        });
        fileUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                console.log('File selected:', file.name);
                optionsMenu.classList.remove('visible');
            }
        });

        // --- NEW: Voice Input (Speech Recognition) Logic ---
        
        // 1. Check for browser support
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = SpeechRecognition ? new SpeechRecognition() : null;
        let currentTargetInput = null; // This will hold the input field we're recording for

        if (recognition) {
            recognition.continuous = false; // Stop after the first phrase
            recognition.lang = 'en-US';
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            // 2. Handle the result
            recognition.onresult = (event) => {
                // Get the transcript from the last result
                const transcript = event.results[event.results.length - 1][0].transcript.trim();
                
                if (currentTargetInput) {
                    // Append the transcript to the target input
                    currentTargetInput.value += (currentTargetInput.value.length > 0 ? ' ' : '') + transcript;
                    
                    // IMPORTANT: Manually trigger the 'input' event for the Step 1 textarea
                    // This ensures its 'disabled' state updates correctly
                    if (currentTargetInput.id === 'topic-input') {
                        dom.topicInput.dispatchEvent(new Event('input'));
                    }
                }
            };

            // 3. Handle errors
            recognition.onerror = (event) => {
                console.error("Speech recognition error", event.error);
                if (currentTargetInput) {
                    // Reset the button icon on error
                    currentTargetInput.closest('.relative').querySelector('.voice-btn i').className = 'fa-solid fa-microphone';
                }
            };

            // 4. Reset button when recognition ends
            recognition.onend = () => {
                if (currentTargetInput) {
                    // Reset the button icon when done
                    currentTargetInput.closest('.relative').querySelector('.voice-btn i').className = 'fa-solid fa-microphone';
                    currentTargetInput = null; // We are no longer targeting an input
                }
            };

            // 5. Create a main click handler function
            const handleVoiceInputClick = (event) => {
                // Check if the click (or its parent) is a .voice-btn
                const voiceBtn = event.target.closest('.voice-btn');
                if (!voiceBtn) return; // Not a voice button click

                // Find the associated input (textarea or input) within the same wrapper
                const target = voiceBtn.closest('.relative').querySelector('textarea, input[type="text"]');
                if (!target) return; // No input found

                if (currentTargetInput) {
                    // If we are already recording, stop
                    recognition.stop();
                } else {
                    // Otherwise, start a new recording
                    currentTargetInput = target;
                    recognition.start();
                    // Update button icon to show it's listening
                    voiceBtn.querySelector('i').className = 'fa-solid fa-stop apg-gradient-text';
                }
            };

            // 6. Add a single *delegated* listener to the body
            // This will catch clicks on all current AND future .voice-btn elements
            document.body.addEventListener('click', handleVoiceInputClick);

        } else {
            // Speech recognition not supported in this browser
            console.warn("Speech Recognition not supported by this browser.");
            // Hide all voice buttons if the API is not available
            const style = document.createElement('style');
            style.innerHTML = `.voice-btn { display: none; }`;
            document.head.appendChild(style);
        }
        // --- END OF NEW VOICE LOGIC ---
        
        // --- Event Listeners & Initialization (MODIFIED) ---
        const resetToStart = () => {
            state = { currentStep: 0, userTopic: '', questionsAndAnswers: [], manualInput: '', generatedPrompt: '' };
            dom.topicInput.value = '';
            dom.questionsContainer.innerHTML = '';
            dom.step1Btn.disabled = true;
            dom.refineOptions.classList.add('hidden');
            
            const manualInputEl = document.getElementById('manual-input-div');
            if(manualInputEl) manualInputEl.remove();
            dom.addInputBtn.style.display = 'inline-block';

            updateStepUI();
        };

        dom.topicInput.addEventListener('input', () => {
            dom.step1Btn.disabled = dom.topicInput.value.trim() === '';
        });

        dom.step1Btn.addEventListener('click', () => {
            state.userTopic = dom.topicInput.value.trim();
            if (state.userTopic) {
                loadInitialQuestions();
            }
        });

        dom.moreQuestionsBtn.addEventListener('click', askMoreQuestions);

        // This is the handler for the *general* manual input button
        dom.addInputBtn.addEventListener('click', () => {
            dom.addInputBtn.style.display = 'none';
            const inputEl = document.createElement('div');
            inputEl.id = 'manual-input-div';
            // --- MODIFIED: Added relative wrapper, pr-12, and voice button to textarea ---
            inputEl.innerHTML = `
                <label for="manual-input" class="block text-sm font-medium mt-4 mb-2 text-left">Add any other details that weren't covered:</label>
                <div class="relative w-full">
                    <textarea id="manual-input" rows="4" class="w-full p-3 pr-12 rounded-lg border border-border-color"></textarea>
                    <button type="button" class="voice-btn toolbar-btn" style="position: absolute; right: 10px; top: 10px; width: 36px; height: 36px;" title="Voice Input">
                        <i class="fa-solid fa-microphone"></i>
                    </button>
                </div>
            `;
            dom.questionsContainer.appendChild(inputEl);
        });
        
        dom.generatePromptBtn.addEventListener('click', generatePrompt);

        dom.refineMoreBtn.addEventListener('click', () => {
            state.currentStep = 1;
            updateStepUI();
        });

        dom.copyBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(dom.resultText.textContent).then(() => {
                dom.copyText.textContent = 'Copied!';
                setTimeout(() => { dom.copyText.textContent = 'Copy Prompt'; }, 2000);
            });
        });

        dom.startOverBtn.addEventListener('click', resetToStart);

        // --- NEW: Add the delegated event listeners ---
        dom.questionsContainer.addEventListener('click', handleFollowUpClick);
        dom.questionsContainer.addEventListener('click', handleSpecificManualInputClick);

        // Initial UI setup
        resetToStart();
        // --- END OF MODIFIED SCRIPT ---
    </script>
</body>
</html>
